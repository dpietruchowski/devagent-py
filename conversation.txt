[{"role": "user", "content": "dodaj log przy inicjalizaji z jakiego modelu korzysta. dodaj r\u00f3wnie\u017c metode set_model() i tam tez dodaj log"}, {"role": "assistant", "content": "The modifications have been made to the `src/agents.py` file. \n\n1. A log message has been added to the constructor (`__init__`) of the `Agent` class to indicate the model being initialized.\n2. A `set_model` method has been added to update the model and log the change.\n\nHere is the modified content of `src/agents.py`:\n\n```python\nimport inspect\nimport json\nimport re\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\ndef parse_param_docstring(docstring):\n    param_descriptions = {}\n    param_pattern = re.compile(r\":param (\\\\w+): (.+)\")\n    for match in param_pattern.findall(docstring):\n        param_name, description = match\n        param_descriptions[param_name] = description.strip()\n    return param_descriptions\n\ndef parse_description_docstring(docstring):\n    lines = docstring.strip().splitlines()\n    description_lines = []\n    for line in lines:\n        if re.match(r'^\\\\s*:\\\\w+\\\\s', line):\n            break\n        print(line)\n        description_lines.append(line.strip())\n    return ' '.join(description_lines).strip()\n\ndef python_type_to_string(python_type):\n    if python_type == \"str\":\n        return \"string\"\n    return python_type\n\ndef function_to_dict(fun):\n    fun_name = fun.__name__\n    fun_doc = fun.__doc__\n    sig = inspect.signature(fun)\n    parameters = {\n        \"type\": \"object\",\n        \"required\": [],\n        \"properties\": {},\n        \"additionalProperties\": False\n    }\n    param_descriptions = parse_param_docstring(fun_doc)\n    description = parse_description_docstring(fun_doc)\n    for param_name, param in sig.parameters.items():\n        param_info = {\n            \"description\": param_descriptions.get(param_name, f\"No description provided for {param_name}\"), \n        }\n        parameters[\"required\"].append(param_name)\n        if param.annotation is not param.empty:\n            type_annotation = str(param.annotation).replace(\"<class '\", \"\").replace(\"'>\", \"\")\n            param_info[\"type\"] = python_type_to_string(type_annotation)\n        else:\n            param_info[\"type\"] = \"string\"\n            parameters[\"properties\"][param_name] = param_info\n    output = {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": fun_name,\n            \"description\": description,\n            \"strict\": True,\n            \"parameters\": parameters\n        }\n    }\n    return output\n\ndef functions_to_dict(functions):\n    functions_info = [function_to_dict(fun) for fun in functions]\n    return functions_info\n\nclass Agent:\n    max_handle_tool_calls = 5\n\n    def __init__(self, name, model, system_prompt=None, system_prompt_file=None, tools=[]):\n        self.token_usage = 0\n        self.cached_token_usage = 0\n        self.handle_tool_calls_count = 0\n        self.name = name\n        self.model = model\n        self.tools = tools\n        self.tools_dict = functions_to_dict(tools)\n        self.log_info(f\"Initialized with model: {self.model}\")\n\n        if system_prompt is not None:\n            self.system_prompt = system_prompt\n        elif system_prompt_file is not None:\n            with open(system_prompt_file, 'r', encoding='utf-8') as file:\n                self.system_prompt = file.read()\n        else:\n            raise ValueError(\"You must specify either 'system_prompt' or 'system_prompt_file'.\")\n\n        self.clear()\n\n    def log_info(self, message):\n        logging.info(f\"[{self.name}] {message}\")\n\n    def log_error(self, message):\n        logging.error(f\"[{self.name}] {message}\")\n\n    def log_warning(self, message):\n        logging.warning(f\"[{self.name}] {message}\")\n\n    def set_model(self, model):\n        self.model = model\n        self.log_info(f\"Model set to: {self.model}\")\n\n    def request(self, client, message):\n        self.messages.append({\"role\": \"user\", \"content\": message})\n        self.handle_tool_calls_count = 0\n        self.log_info(f\"User request: {message}\")\n        return self.create_completion(client)\n\n    def get_user_assistant_messages(self):\n        return [\n            {'role': msg['role'], 'content': msg['content']}\n            for msg in self.messages\n            if msg.get('role') in {'user', 'assistant'} and msg.get('content')\n        ]\n\n    def create_completion(self, client):\n        if self.tools_dict:\n            completion = client.chat.completions.create(\n                model=self.model,\n                messages=self.messages,\n                tools=self.tools_dict\n            )\n        else:\n            completion = client.chat.completions.create(\n                model=self.model,\n                messages=self.messages,\n            )\n\n        self.token_usage += completion.usage.total_tokens\n        self.cached_token_usage += completion.usage.cached_tokens if 'cached_tokens' in completion.usage else 0\n        self.log_info(f\"Token usage updated: {completion.usage.total_tokens}, Total tokens used: {self.token_usage}, Cached tokens: {self.cached_token_usage}\")\n\n        if completion.choices[0].finish_reason == \"tool_calls\":\n            self.log_info(\"The model has initiated a tool call.\")\n            self.messages.append(completion.choices[0].message.dict())\n            return self.handle_tool_calls(client, completion.choices[0].message.tool_calls)\n\n        response = completion.choices[0].message.content\n        self.messages.append({\"role\": \"assistant\", \"content\": response})\n        self.log_info(f\"Assistant response: {response}\")\n\n        return response\n\n    def clear(self):\n        self.messages = [\n            {\"role\": \"system\", \"content\": self.system_prompt}\n        ]\n\n    def soft_reset(self):\n        user_assistans_messages = self.get_user_assistant_messages()\n        self.clear()\n        self.messages.extend(user_assistans_messages)\n    \n    def handle_tool_calls(self, client, tool_calls):\n        if self.handle_tool_calls_count > self.max_handle_tool_calls:\n            self.log_error(f\"Exceeded maximum tool calls limit: {self.handle_tool_calls_count}\")\n            return \"\"\n\n        for tool_call in tool_calls:\n            function = find_function_by_name(self.tools, tool_call.function.name)\n            if not function:\n                self.log_error(\"Tool call failed: Function not found.\")\n                continue\n\n            arguments = json.loads(tool_call.function.arguments)\n            if isinstance(arguments, list):\n                ret = function(*arguments)\n            elif isinstance(arguments, dict):\n                ret = function(**arguments)\n            else:\n                self.log_error(\"Invalid arguments format received for the tool call.\")\n\n            self.messages.append({\n                \"role\": \"tool\",\n                \"content\": json.dumps(ret),\n                \"tool_call_id\": tool_call.id\n            })\n\n        return self.create_completion(client)\n```\n\nLet me know if you need any further modifications or assistance!"}]